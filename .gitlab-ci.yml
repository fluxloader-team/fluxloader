stages:
  - build
  - release

variables:
  OUTPUT_DIR: dist
  APP_ID: "app.fluxloader.Fluxloader"
  PRODUCT_NAME: "Fluxloader"
  LEGACY_ELECTRON_VERSION: "22.3.27"

.build_template:
  stage: build
  tags:
    - linux
  image: node:20
  before_script:
    - dpkg --add-architecture i386
    - >-
      apt-get update && apt-get install -y --no-install-recommends
      wine wine32:i386
      build-essential gcc g++ make git python3
      dpkg fakeroot
      libarchive-tools
      icnsutils graphicsmagick xz-utils
      clang libc++-dev libc++abi-dev libgconf-2-4 rpm libx11-dev libxkbfile-dev
      libsecret-1-dev libgbm-dev
      && rm -rf /var/lib/apt/lists/*
    - echo "--- Wine Debug Info ---"
    - which wine || echo "wine not found in PATH"
    - which wine64 || echo "wine64 not found in PATH"
    - which wine32 || echo "wine32 not found in PATH"
    - dpkg -l | grep wine || echo "No wine packages found via dpkg"
    - wine --version || echo "wine --version command failed"
    - echo "--- Environment PATH ---"
    - printenv PATH
    - echo "--- End Debug Info ---"
    - npm install -g npm@latest
    - echo "Cleaning npm cache..."
    - npm cache clean --force
    - echo "Installing project dependencies (including electron-builder from package.json)..."
    - npm install --legacy-peer-deps --no-audit --prefer-offline --progress=false
    - echo "Node modules installed."
    - ls node_modules || echo "node_modules not found after install!"
    - echo "Verifying electron-builder version:"
    - ./node_modules/.bin/electron-builder --version || echo "Cannot get electron-builder version via direct path"
  script:
    - set -eo pipefail
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        echo "Using Git tag for build version: $CI_COMMIT_TAG"
        EFFECTIVE_BUILD_VERSION="$CI_COMMIT_TAG"
      else
        echo "No Git tag found. Using package.json version."
        EFFECTIVE_BUILD_VERSION=$(node -p "require('./package.json').version" || echo "error")
        if [ "$EFFECTIVE_BUILD_VERSION" == "error" ] || [ -z "$EFFECTIVE_BUILD_VERSION" ]; then
          echo "Error: Cannot read version from package.json"
          exit 1
        fi
        echo "Using package.json version: $EFFECTIVE_BUILD_VERSION"
      fi
      export EFFECTIVE_BUILD_VERSION
    - echo "Starting build for $CI_JOB_NAME with version $EFFECTIVE_BUILD_VERSION"
    - rm -rf $OUTPUT_DIR && mkdir -p $OUTPUT_DIR

build-macos-x64:
  extends: .build_template
  script:
    - !reference [.build_template, script]
    - npm install --save-dev dmg-builder --legacy-peer-deps --no-audit
    - ./node_modules/.bin/electron-builder --mac dmg --x64 --config.buildVersion="$EFFECTIVE_BUILD_VERSION" --config.mac.identity=null
  artifacts:
    paths:
      - $OUTPUT_DIR/*.dmg
    expire_in: 1 week

build-macos-arm64:
  extends: .build_template
  script:
    - !reference [.build_template, script]
    - npm install --save-dev dmg-builder --legacy-peer-deps --no-audit
    - ./node_modules/.bin/electron-builder --mac dmg --arm64 --config.buildVersion="$EFFECTIVE_BUILD_VERSION" --config.mac.identity=null
  artifacts:
    paths:
      - $OUTPUT_DIR/*.dmg
    expire_in: 1 week

release-job:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  tags:
    - linux
  needs:
    - job: build-macos-x64
      artifacts: true
    - job: build-macos-arm64
      artifacts: true
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - echo "Starting release process for tag $CI_COMMIT_TAG"
    - echo "Files in workspace (merged artifacts):"
    - ls -lR .
    - |
      ASSETS_JSON="["
      FIRST_ASSET=true
      # Adjusted find command slightly - blockmap only expected from legacy job now
      find . -maxdepth 2 \( -name "*.exe" -o -name "*-Legacy*.blockmap" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.dmg" \) -print0 | while IFS= read -r -d $'\0' file; do
          filepath_relative=$(realpath --relative-to=. "$file")
          filename=$(basename "$filepath_relative")
          filepath_upload="/$filename"
          display_name=$(echo "$filename" | sed 's/"/\\"/g')

          PACKAGE_UPLOAD_URL="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${PRODUCT_NAME}/${CI_COMMIT_TAG}"
          PACKAGE_DOWNLOAD_URL="${PACKAGE_UPLOAD_URL}/${filename}"

          echo "Uploading ${filename} (from ${filepath_relative}) to Generic Package Registry..."
          curl --fail --retry 5 --retry-delay 2 --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
               --upload-file "$filepath_relative" \
               "${PACKAGE_UPLOAD_URL}/${filename}" || exit 1
          echo "Upload complete for ${filename}."

          if [ "$FIRST_ASSET" = true ]; then
              FIRST_ASSET=false
          else
              ASSETS_JSON="${ASSETS_JSON},"
          fi

          ASSETS_JSON="${ASSETS_JSON}{\"name\":\"${display_name}\",\"url\":\"${PACKAGE_DOWNLOAD_URL}\",\"filepath\":\"${filepath_upload}\",\"link_type\":\"package\"}"
      done
      ASSETS_JSON="${ASSETS_JSON}]"

      if [ "$ASSETS_JSON" == "[]" ]; then
        echo "ERROR: No artifact files found to upload/release!"
        exit 1
      fi
      echo "Generated Assets JSON: ${ASSETS_JSON}"
    - echo "Creating GitLab Release..."
    - |
      release-cli create --name "Release $CI_COMMIT_TAG" \
                         --tag-name "$CI_COMMIT_TAG" \
                         --description "Automated release for tag $CI_COMMIT_TAG. Download builds from the assets below." \
                         --assets-link "${ASSETS_JSON}"
    - echo "GitLab Release created successfully!"